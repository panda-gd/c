C语言指针
---------------------
指针就是数据或者指令的地址。C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用

### 指针变量
> 在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量

### 指针变量的定义
> datatype * name 表示定义了一个指向datatype类型的指针
> int a = 100;int * p_a = &a;在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了a 值得注意的是，p_a 需要的一个地址，a前面必须要加取地址符&，否则是不对的
> 需要强调的是，p_a的类型分别是int* ，而不是int，它们是完全不同的数据类型

### 指针数组
> 如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）
> int arr[] = {1,2,3} arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以int * p = arr;也可以写作int * p = &arr[0]  也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头
> int i, * p = arr, len = sizeof(arr) / sizeof(int);求数组长度  数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用sizeof(p) / sizeof(int)，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数
> 数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关,数组的类型是int ，p 的类型必须也是int * 

### 关于数组指针的谜题
*假设p是指向数组arr中第n个元素的指针，那么 *p++、*++p、(*p)++ 分别是什么意思呢？
*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素，上面已经进行了详细讲解。
*++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。
(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。

### 注意
> 虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符，但在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址
> * 是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带* 。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上* ，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带* ，给指针变量赋值时不能带* 
